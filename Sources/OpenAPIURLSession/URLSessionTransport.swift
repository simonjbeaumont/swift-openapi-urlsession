//===----------------------------------------------------------------------===//
//
// This source file is part of the SwiftOpenAPIGenerator open source project
//
// Copyright (c) 2023 Apple Inc. and the SwiftOpenAPIGenerator project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of SwiftOpenAPIGenerator project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//
import OpenAPIRuntime
import HTTPTypes
#if canImport(Darwin)
import Foundation
#else
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.URLComponents
@preconcurrency import struct Foundation.Data
@preconcurrency import protocol Foundation.LocalizedError
#endif
#if canImport(FoundationNetworking)
@preconcurrency import struct FoundationNetworking.URLRequest
@preconcurrency import class FoundationNetworking.URLSession
@preconcurrency import class FoundationNetworking.URLResponse
@preconcurrency import class FoundationNetworking.HTTPURLResponse
#endif

/// A client transport that performs HTTP operations using the URLSession type
/// provided by the Foundation framework.
///
/// ### Use the URLSession transport
///
/// Instantiate the transport:
///
///     let transport = URLSessionTransport()
///
/// Create the base URL of the server to call using your client. If the server
/// URL was defined in the OpenAPI document, you find a generated method for it
/// on the `Servers` type, for example:
///
///     let serverURL = try Servers.server1()
///
/// Instantiate the `Client` type generated by the Swift OpenAPI Generator for
/// your provided OpenAPI document. For example:
///
///     let client = Client(
///         serverURL: serverURL,
///         transport: transport
///     )
///
/// Use the client to make HTTP calls defined in your OpenAPI document. For
/// example, if the OpenAPI document contains an HTTP operation with
/// the identifier `checkHealth`, call it from Swift with:
///
///     let response = try await client.checkHealth(.init())
///     // ...
///
/// ### Provide a custom URLSession
///
/// The ``URLSessionTransport/Configuration-swift.struct`` type allows you to
/// provide a custom URLSession and tweak behaviors such as the default
/// timeouts, authentication challenges, and more.
public struct URLSessionTransport: ClientTransport {

    /// A set of configuration values for the URLSession transport.
    public struct Configuration: Sendable {

        /// The URLSession used for performing HTTP operations.
        public var session: URLSession

        /// The buffer size to use for streaming uploads.
        public var uploadBufferSize: Int

        /// Creates a new configuration with the provided session.
        /// - Parameters:
        ///     - session: The URLSession used for performing HTTP operations.
        ///     If none is provided, the system uses the shared URLSession.
        ///     - uploadBufferSize: The size (in bytes) of the buffer for streaming request bodies.
        public init(
            session: URLSession = .shared,
            uploadBufferSize: Int = 4096
        ) {
            self.session = session
            self.uploadBufferSize = uploadBufferSize
        }
    }

    /// A set of configuration values used by the transport.
    public var configuration: Configuration

    /// Creates a new URLSession-based transport.
    /// - Parameters:
    ///   - configuration: A set of configuration values used by the transport.
    public init(configuration: Configuration = .init()) {
        self.configuration = configuration
    }

    public func send(
        _ request: HTTPRequest,
        body requestBody: HTTPBody?,
        baseURL: URL,
        operationID: String
    ) async throws -> (HTTPResponse, HTTPBody?) {
        /// Delegate that supports streaming a request body.
        ///
        /// There are some quirks to this delegate that are borne out of the desire to perform
        /// bidirectional streaming with backpressure, but without reimplementing what URLSession
        /// already does internally.
        ///
        /// Specifically, URLSession provides a high-level API that returns an async sequence of
        /// bytes, `bytes(for:delegate:)`, but does not provide an API that takes an async sequence
        /// as a request body. For instance, `upload(for:delegate:)` and `upload(fromFile:delegate:)`
        /// both buffer the entire response body and return `Data`.
        ///
        /// One option is to use `uploadTask(withStreamedRequest:delegate:)` which will ask the
        /// delegate for a new `InputStream` via `urlSession(_:needNewBodyStreamForTask:)`.
        ///
        /// This is a workable approach for streaming the request body, but will require
        /// reimplementing the bridging of response data to an async sequence using
        /// `urlSession(_:didReceive data:)`, which will also require reimplementing backpressure
        /// by suspeding and resuming the URLSession task.
        ///
        /// Even with such response body bridging in place, we would then need to make a runtime
        /// decision on whether to use an `UploadTask` or a `DataTask` depending on the nature of
        /// the request being made, which is overly complex.
        ///
        /// Instead we take a hybrid approach that only requires us to bridge the request body async
        /// sequence. We use `bytes(for:delegate:)` in all cases, which takes care of bridging the
        /// response body to an async sequence with backpressure.
        ///
        /// Providing a delegate that implements `urlSession(_:needNewBodyStreamForTask:)` does not
        /// cause URLSession to use it for the initial request body during `bytes(for:delegate)`.
        /// This delegate method is only used to get the initial request body stream when using
        /// `uploadTask(withStreamedRequest:)`.
        ///
        /// Instead, we rely on URLSession using the request body in the URLRequest, which it takes
        /// from either the `httpBody: Data?` or `httpBodyStream: InputStream?` properties, and if
        /// `httpBodyStream` is non-nil, it will be used and the task will be treated as a streaming
        /// request.
        ///
        /// Because `httpBodyStream` is present when the URLSession task is created, URLSession will
        /// _not_ call `urlSession(_:needNewBodyStreamForTask:)` _initially_, but _might_ call it
        /// later, e.g. on a redirect.
        final class URLSessionTransportTaskDelegate: NSObject, URLSessionTaskDelegate {

            let requestBody: HTTPBody
            let streamBufferSize: Int
            var inputStream: InputStream
            var outputStream: OutputStream
            var requestStream: HTTPBodyOutputStreamBridge

            var completion: CheckedContinuation<Void, any Error>? = nil

            init(requestBody: HTTPBody, streamBufferSize: Int) {
                self.requestBody = requestBody
                self.streamBufferSize = streamBufferSize
                // Create a pair of bound streams.
                (self.inputStream, self.outputStream) = Self.createStreamPair(withBufferSize: streamBufferSize)
                // Bridge the output stream to the request body, but don't open the output stream;
                // it will be opened in the `didCreateTask` callback.
                self.requestStream = HTTPBodyOutputStreamBridge(outputStream, requestBody, openOutputStream: false)
            }

            static func createStreamPair(withBufferSize bufferSize: Int) -> (InputStream, OutputStream) {
                var inputStream: InputStream?
                var outputStream: OutputStream?
                Stream.getBoundStreams(
                    withBufferSize: bufferSize,
                    inputStream: &inputStream,
                    outputStream: &outputStream
                )
                guard let inputStream, let outputStream else {
                    fatalError("getBoundStreams did not return non-nil streams")
                }
                return (inputStream, outputStream)
            }

            func urlSession(
                _ session: URLSession,
                task: URLSessionTask,
                willPerformHTTPRedirection response: HTTPURLResponse,
                newRequest request: URLRequest
            ) async -> URLRequest? {
                debug("Task delegate: willPerfromHTTPRediection")
                return request
            }

            func urlSession(_ session: URLSession, didCreateTask task: URLSessionTask) {
                debug("Task delegate: didCreateTask")
                precondition(outputStream.streamStatus == .notOpen)
                outputStream.open()
            }

            func urlSession(_ session: URLSession, needNewBodyStreamForTask task: URLSessionTask) async -> InputStream?
            {
                debug("Task delegate: needNewBodyStreamForTask")
                // Because we're _not_ using uploadTask(withStreamedRequest:), this will
                // _only_ be called if we need to do perform the request again, e.g. on
                // redirection. In this instance, the output stream should be closed already.
                precondition(outputStream.streamStatus == .closed)

                // If the HTTP body cannot be iterated multiple times then bad luck; the only thing
                // we can do is cancel the task and return nil.
                guard requestBody.iterationBehavior == .multiple else {
                    debug("Task delegate: Cannot rewind request body, canceling task")
                    task.cancel()
                    return nil
                }

                // Create a fresh pair of streams.
                (self.inputStream, self.outputStream) = Self.createStreamPair(withBufferSize: streamBufferSize)

                // Bridge the output stream to the request body and open the output stream.
                requestStream = HTTPBodyOutputStreamBridge(outputStream, requestBody, openOutputStream: true)

                // Return the new input stream (unopened, it gets opened by URLSession).
                return inputStream
            }

            //            func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: (any Error)?) {
            //                if let error {
            //                    self.completion?.resume(throwing: error)
            //                } else {
            //                    self.completion?.resume()
            //                }
            //            }
            //
            //            func wait() async throws {
            //                try await withCheckedThrowingContinuation { continuation in
            //                    self.completion = continuation
            //                }
            //            }
        }

        var urlRequest = try URLRequest(request, baseURL: baseURL)
        var taskDelegate: URLSessionTransportTaskDelegate? = nil

        if let requestBody {
            taskDelegate = URLSessionTransportTaskDelegate(
                requestBody: requestBody,
                streamBufferSize: configuration.uploadBufferSize
            )
            if case .known(let length) = requestBody.length {
                urlRequest.setValue("\(length)", forHTTPHeaderField: "Content-Length")
            }
            urlRequest.httpBodyStream = taskDelegate!.inputStream
        }

        let (bytes, response) = try await configuration.session.bytes(for: urlRequest, delegate: taskDelegate)

        let responseBody = HTTPBody(
            bytes.map { [taskDelegate] in
                _ = taskDelegate
                return [$0]
            },
            length: HTTPBody.Length(from: response),
            iterationBehavior: .single
        )

        return (try HTTPResponse(response), responseBody)
    }
}

extension HTTPBody.Length {
    init(from urlResponse: URLResponse) {
        if urlResponse.expectedContentLength == -1 {
            self = .unknown
        } else {
            self = .known(Int(urlResponse.expectedContentLength))
        }
    }
}

/// Specialized error thrown by the transport.
internal enum URLSessionTransportError: Error {

    /// Invalid URL composed from base URL and received request.
    case invalidRequestURL(path: String, method: HTTPRequest.Method, baseURL: URL)

    /// Returned `URLResponse` could not be converted to `HTTPURLResponse`.
    case notHTTPResponse(URLResponse)

    /// Returned `URLResponse` was nil
    case noResponse(url: URL?)
}

extension HTTPResponse {
    init(_ urlResponse: URLResponse) throws {
        guard let httpResponse = urlResponse as? HTTPURLResponse else {
            throw URLSessionTransportError.notHTTPResponse(urlResponse)
        }
        var headerFields = HTTPFields()
        for (headerName, headerValue) in httpResponse.allHeaderFields {
            guard
                let rawName = headerName as? String,
                let name = HTTPField.Name(rawName),
                let value = headerValue as? String
            else {
                continue
            }
            headerFields[name] = value
        }
        self.init(
            status: .init(code: httpResponse.statusCode),
            headerFields: headerFields
        )
    }
}

extension URLRequest {
    init(_ request: HTTPRequest, baseURL: URL) throws {
        guard
            var baseUrlComponents = URLComponents(string: baseURL.absoluteString),
            let requestUrlComponents = URLComponents(string: request.path ?? "")
        else {
            throw URLSessionTransportError.invalidRequestURL(
                path: request.path ?? "<nil>",
                method: request.method,
                baseURL: baseURL
            )
        }

        let path = requestUrlComponents.percentEncodedPath
        baseUrlComponents.percentEncodedPath += path
        baseUrlComponents.percentEncodedQuery = requestUrlComponents.percentEncodedQuery
        guard let url = baseUrlComponents.url else {
            throw URLSessionTransportError.invalidRequestURL(
                path: path,
                method: request.method,
                baseURL: baseURL
            )
        }
        self.init(url: url)
        self.httpMethod = request.method.rawValue
        for header in request.headerFields {
            self.setValue(header.value, forHTTPHeaderField: header.name.canonicalName)
        }
    }
}

extension URLSessionTransportError: LocalizedError {
    public var errorDescription: String? { description }
}

extension URLSessionTransportError: CustomStringConvertible {
    public var description: String {
        switch self {
        case let .invalidRequestURL(path: path, method: method, baseURL: baseURL):
            return
                "Invalid request URL from request path: \(path), method: \(method), relative to base URL: \(baseURL.absoluteString)"
        case .notHTTPResponse(let response):
            return "Received a non-HTTP response, of type: \(String(describing: type(of: response)))"
        case .noResponse(let url):
            return "Received a nil response for \(url?.absoluteString ?? "<nil URL>")"
        }
    }
}

func debug(_ items: Any..., separator: String = " ", terminator: String = "\n") {
    assert(
        {
            print(items, separator: separator, terminator: terminator)
            return true
        }()
    )
}
